package main

import (
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/cnative/pkg/log"
	grpc_runtime "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"golang.org/x/net/context"
	empty "google.golang.org/protobuf/types/known/emptypb"

	"{{ .ModuleName }}/internal/models"
	"{{ .ModuleName }}/internal/state"
	api "{{ .ModuleName }}/pkg/api/v1"
)

type {{ LowerCase .ResourceName }}Service struct {
	store  state.{{ .ResourceName }}Store
	logger log.Logger

	api.Unimplemented{{ .ResourceName }}SvcServer
}

// Make sure that {{ LowerCase .ResourceName }}Service implements the api.{{ .ResourceName }}SvcServer interface
var _ api.{{ .ResourceName }}SvcServer = &{{ LowerCase  .ResourceName }}Service{}

// NewServiceHandler Creates a new {{ LowerCase  .ResourceName }}Service which implements api.{{ .ResourceName }}SvcServer
func newServiceHandler(store state.{{ .ResourceName }}Store, l log.Logger) *{{ LowerCase .ResourceName }}Service {
	if l == nil {
		l = log.NewNop()
	}
	return &{{ LowerCase .ResourceName }}Service{
		store:  store,
		logger: l}
}

// Register registers this controlPlane on s.
//
// It implements server.GRPCAPIHandler.
func (u *{{ LowerCase .ResourceName }}Service) Register(ctx context.Context, s *grpc.Server, mux *grpc_runtime.ServeMux, conn *grpc.ClientConn) error {
	api.Register{{ .ResourceName }}SvcServer(s, u)
	if mux == nil {
		return nil
	}

	return api.Register{{ .ResourceName }}SvcHandler(ctx, mux, conn)
}

// Close closes the server.
//
// It implements server.GRPCAPIHandler.
func (u *{{ LowerCase .ResourceName }}Service) Close() error {
	return nil
}

// *models.{{  .ResourceName }} -> *api.{{  .ResourceName }}
func toResponse{{  .ResourceName }}(mr *models.{{ .ResourceName }}) *api.{{  .ResourceName }} {
	return &api.{{  .ResourceName }}{
		Id:         mr.GetId(),
		Name:       models.FQResource(models.ResourceType_{{ UpperCase .ResourceName }}, mr.GetName()).String(),
		Labels:     mr.Labels,
		Creator:    mr.GetCreator(),
		CreateTime: mr.GetCreateTime(),
	}
}

func (u *{{ LowerCase .ResourceName }}Service) Create{{ .ResourceName }}(ctx context.Context, req *api.Create{{  .ResourceName }}Request) (*api.{{  .ResourceName }}, error) {

	return nil, status.Error(codes.Unimplemented, "coming soon")
}

func (u *{{ LowerCase .ResourceName }}Service) Get{{ .ResourceName }}(ctx context.Context, req *api.Get{{  .ResourceName }}Request) (*api.{{  .ResourceName }}, error) {
	mr := models.Resource(req.Name)
	mrn := mr.GetName()

	if mr.GetType() != models.ResourceType_{{ UpperCase .ResourceName }} || mrn == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid {{  .ResourceName }} name")
	}

	{{  .ResourceName }}, err := u.store.Get{{ .ResourceName }}(ctx, mrn)
	if err != nil {
		return nil, err
	}

	return toResponse{{  .ResourceName }}({{ .ResourceName }}), nil
}

func (u *{{ LowerCase .ResourceName }}Service) List{{ .ResourceName }}s(ctx context.Context, req *api.List{{  .ResourceName }}sRequest) (*api.List{{  .ResourceName }}sResponse, error) {

	if req == nil {
		req = &api.List{{  .ResourceName }}sRequest{}
	}

	results, nextPageToken, err := u.store.List{{ .ResourceName }}s(ctx, newListArgs(req.Filter, req.PageSize, req.PageToken))
	if err != nil {
		return nil, err
	}

	items := make([]*api.{{  .ResourceName }}, 0, len(results))
	for _, mr := range results {
		items = append(items, toResponse{{ .ResourceName }}(mr))
	}

	return &api.List{{ .ResourceName }}sResponse{
		{{  .ResourceName }}s:          items,
		NextPageToken: nextPageToken,
	}, nil
}

func (u *{{ LowerCase .ResourceName }}Service) Update{{ .ResourceName }}(ctx context.Context, req *api.Update{{ .ResourceName }}Request) (*api.{{ .ResourceName }}, error) {

	return nil, status.Error(codes.Unimplemented, "coming soon")
}

func (u *{{ LowerCase .ResourceName }}Service) Delete{{ .ResourceName }}(ctx context.Context, req *api.Delete{{ .ResourceName }}Request) (*empty.Empty, error) {

	return &empty.Empty{}, u.store.Delete{{  .ResourceName }}(ctx, req.Name)
}
