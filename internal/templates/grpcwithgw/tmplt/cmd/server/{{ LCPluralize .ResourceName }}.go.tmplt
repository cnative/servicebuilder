package main

import (
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/cnative/pkg/auth"
	"github.com/cnative/pkg/log"
	grpc_runtime "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"golang.org/x/net/context"
	empty "google.golang.org/protobuf/types/known/emptypb"

	"{{ .ModuleName }}/internal/models"
	"{{ .ModuleName }}/internal/state"
	api "{{ .ModuleName }}/pkg/api/v1"
)

type {{ LowerCase .ResourceName }}Service struct {
	store  state.{{ .ResourceName }}Store
	logger log.Logger

	api.Unimplemented{{ .ResourceName }}SvcServer
}

// Make sure that {{ LowerCase .ResourceName }}Service implements the api.{{ .ResourceName }}SvcServer interface
var _ api.{{ .ResourceName }}SvcServer = &{{ LowerCase  .ResourceName }}Service{}

// NewServiceHandler Creates a new {{ LowerCase  .ResourceName }}Service which implements api.{{ .ResourceName }}SvcServer
func newServiceHandler(store state.{{ .ResourceName }}Store, l log.Logger) *{{ LowerCase .ResourceName }}Service {
	if l == nil {
		l = log.NewNop()
	}
	return &{{ LowerCase .ResourceName }}Service{
		store:  store,
		logger: l}
}

// Register registers this service.
//
// It implements server.GRPCAPIHandler.
func (s *{{ LowerCase .ResourceName }}Service) Register(ctx context.Context, srv *grpc.Server, mux *grpc_runtime.ServeMux, conn *grpc.ClientConn) error {
	api.Register{{ .ResourceName }}SvcServer(srv, s)
	if mux == nil {
		return nil
	}

	return api.Register{{ .ResourceName }}SvcHandler(ctx, mux, conn)
}

// Close closes the server.
//
// It implements server.GRPCAPIHandler.
func (s *{{ LowerCase .ResourceName }}Service) Close() error {
	return nil
}

// *models.{{ .ResourceName }} -> *api.{{ .ResourceName }}
func toResponse{{ .ResourceName }}(mr *models.{{ .ResourceName }}) *api.{{ .ResourceName }} {
	return &api.{{ .ResourceName }}{
		Id:             mr.GetId(),
		Name:           models.FQResource(models.ResourceType_{{ UpperCase .ResourceName }}, mr.GetName()).String(),
		Labels:         mr.Labels,
		Creator:        mr.GetCreator(),
		CreateTime:     mr.GetCreateTime(),
		LastUpdater:    mr.GetUpdater(),
		LastUpdateTime: mr.GetUpdateTime(),
	}
}

func (s *{{ LowerCase .ResourceName }}Service) Create{{ .ResourceName }}(ctx context.Context, req *api.Create{{ .ResourceName }}Request) (*api.{{ .ResourceName }}, error) {
	if req == nil || req.{{ .ResourceName }} == nil {
		return nil, status.Errorf(codes.InvalidArgument, "req or {{ LowerCase .ResourceName }} is nil")
	}

	cr := models.Resource(req.{{ .ResourceName }}.Name)
	crn := cr.GetName()
	if cr.GetType() != models.ResourceType_{{ UpperCase .ResourceName }} || crn == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid {{ LowerCase .ResourceName }} name")
	}

	currentUser := auth.CurrentUser(ctx)
	m{{ .ResourceName }} := &models.{{ .ResourceName }}{
		Name:    crn,
		Labels:  req.{{ .ResourceName }}.Labels,
		Creator: currentUser,
		Updater: currentUser,
	}

	mr, err := s.store.Create{{ .ResourceName }}(ctx, m{{ .ResourceName }})
	if err != nil {
		return nil, err
	}

	return toResponse{{ .ResourceName }}(mr), nil
}

func (s *{{ LowerCase .ResourceName }}Service) Get{{ .ResourceName }}(ctx context.Context, req *api.Get{{ .ResourceName }}Request) (*api.{{ .ResourceName }}, error) {
	mr := models.Resource(req.Name)
	mrn := mr.GetName()
	if mr.GetType() != models.ResourceType_{{ UpperCase .ResourceName }} || mrn == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid {{ .ResourceName }} name")
	}

	m{{ .ResourceName }}, err := s.store.Get{{ .ResourceName }}(ctx, mrn)
	if err != nil {
		return nil, err
	}

	return toResponse{{ .ResourceName }}(m{{ .ResourceName }}), nil
}

func (s *{{ LowerCase .ResourceName }}Service) List{{ Pluralize .ResourceName }}(ctx context.Context, req *api.List{{ Pluralize .ResourceName }}Request) (*api.List{{ Pluralize .ResourceName }}Response, error) {

	if req == nil {
		req = &api.List{{ Pluralize .ResourceName }}Request{}
	}
	results, nextPageToken, err := s.store.List{{ Pluralize .ResourceName }}(ctx, newListArgs(req.Filter, req.PageSize, req.PageToken))
	if err != nil {
		return nil, err
	}

	items := make([]*api.{{ .ResourceName }}, 0, len(results))
	for _, mr := range results {
		items = append(items, toResponse{{ .ResourceName }}(mr))
	}

	return &api.List{{ Pluralize .ResourceName }}Response{
		{{ Pluralize .ResourceName }}:          items,
		NextPageToken: nextPageToken,
	}, nil
}

func (s *{{ LowerCase .ResourceName }}Service) Update{{ .ResourceName }}(ctx context.Context, req *api.Update{{ .ResourceName }}Request) (*api.{{ .ResourceName }}, error) {
	if req == nil || req.{{ .ResourceName }} == nil {
		return nil, status.Errorf(codes.InvalidArgument, "req is nil or req.{{ .ResourceName }} is nil")
	}

	mr := models.Resource(req.{{ .ResourceName }}.Name)
	mrn := mr.GetName()
	if mr.GetType() != models.ResourceType_{{ UpperCase .ResourceName }} || mrn == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid {{ LowerCase .ResourceName }} name")
	}

	if req.UpdateMask == nil || len(req.UpdateMask.Paths) <= 0 {
		return nil, status.Errorf(codes.InvalidArgument, "update mask not specified")
	}

	m{{ .ResourceName }} := &models.{{ .ResourceName }}{
		Name:    mrn,
		Labels:  req.{{ .ResourceName }}.Labels,
		Updater: auth.CurrentUser(ctx),
	}
	ms, err := s.store.Update{{ .ResourceName }}(ctx, req.UpdateMask, m{{ .ResourceName }})
	if err != nil {
		return nil, err
	}

	return toResponse{{ .ResourceName }}(ms), nil
}

func (s *{{ LowerCase .ResourceName }}Service) Delete{{ .ResourceName }}(ctx context.Context, req *api.Delete{{ .ResourceName }}Request) (*empty.Empty, error) {
	mr := models.Resource(req.Name)
	mrn := mr.GetName()
	if mr.GetType() != models.ResourceType_{{ UpperCase .ResourceName }} || mrn == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid {{ LowerCase .ResourceName }} name")
	}

	return &empty.Empty{}, s.store.Delete{{ .ResourceName }}(ctx, mrn)
}
