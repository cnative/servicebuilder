package iwrap

// MetricsTmplt used to wrap an interface with metrics generators
const MetricsTmplt = `
// Code generated by servicebuilder iwrap. DO NOT EDIT.

{{ .ServiceBuilderVersion }}

{{$target := .InterfaceName}}
{{$recv :=  .ReceiverSub  }}

package {{ .PackageName }}
import (
	"context"
	"time"

	"go.opencensus.io/stats"
	"go.opencensus.io/stats/view"
	"go.opencensus.io/tag"
	{{range .CustomImports}}
	"{{.}}"
	{{end}}
)

// {{ lowerCamelCase $target }}Observer
type {{ lowerCamelCase $target }}Observer struct {
}

// {{ lowerCamelCase $target }}WithMetrics wraps {{ $target }} and gathers metrics
type {{ lowerCamelCase $target }}WithMetrics struct {
	wrapped{{$target}}    {{ $target }}
	observer *{{ lowerCamelCase $target }}Observer
}

// {{ $target }}WithMetrics creates a new {{ $target }} with metrics
func {{ $target }}WithMetrics(toWrap {{ $target }}, logger log.Logger) {{ $target }} {
	return &{{ lowerCamelCase $target }}WithMetrics{wrapped{{$target}}: toWrap, observer: &{{ lowerCamelCase $target }}Observer{}}
}

var (

	_ {{ $target }} = (*{{ lowerCamelCase $target }}WithMetrics)(nil)

	// {{ lowerCamelCase $target }}KeyMethod is the label/tag used while reporting metrics
	{{ lowerCamelCase $target }}KeyMethod = tag.MustNewKey("method")

	{{ lowerCamelCase $target }}CallLatency = stats.Float64("{{ snakeCase $target }}/latency", "The latency in milliseconds per call", "ms")
	{{ lowerCamelCase $target }}CallCount   = stats.Int64("{{ snakeCase $target }}/calls", "number of {{ $target }} calls made", "1")
	{{ lowerCamelCase $target }}CallErrorCount   = stats.Int64("{{ snakeCase $target }}/call_errors", "number of {{ $target }} calls that returned error", "1")

	{{ lowerCamelCase $target }}CallLatencyView = &view.View{
		Name:        {{ lowerCamelCase $target }}CallLatency.Name(),
		Measure:     {{ lowerCamelCase $target }}CallLatency,
		Description: "Distribution of call latencies for {{ $target }} methods",

		// Latency in buckets:
		// [>=0ms, >=25ms, >=50ms, >=75ms, >=100ms, >=200ms, >=400ms, >=600ms, >=800ms, >=1s, >=2s, >=4s, >=6s]
		Aggregation: view.Distribution(0, 25, 50, 75, 100, 200, 400, 600, 800, 1000, 2000, 4000, 6000),
		TagKeys:     []tag.Key{ {{ lowerCamelCase $target }}KeyMethod },
    }

	{{ lowerCamelCase $target }}CallCountView = &view.View{
		Name:        {{ lowerCamelCase $target }}CallCount.Name(),
		Measure:     {{ lowerCamelCase $target }}CallCount,
		Description: "Number calls to {{ $target }} methods",
		Aggregation: view.Count(),
	}

	{{ lowerCamelCase $target }}CallErrorCountView = &view.View{
		Name:        {{ lowerCamelCase $target }}CallErrorCount.Name(),
		Measure:     {{ lowerCamelCase $target }}CallErrorCount,
		Description: "Number of calls to {{ $target }} methods that returned error",
		Aggregation: view.Count(),
	}
)

// Observe immediately increments the counter for method and returns a func
// which will observe metric item for execution duration
func ({{$recv}} *{{ lowerCamelCase $target }}Observer) Observe(ctx context.Context, method string) func() {
	ctx, err := tag.New(ctx, tag.Insert({{ lowerCamelCase $target }}KeyMethod, method))
	if err != nil {
		panic(err)
	}

	stats.Record(ctx, {{ lowerCamelCase $target }}CallCount.M(1))
	startTime := time.Now()

	return func() {
		ms := float64(time.Since(startTime).Nanoseconds()) / 1e6
		stats.Record(ctx, {{ lowerCamelCase $target }}CallLatency.M(ms))
	}
}

{{range .Methods}}
{{template "doc" . -}}
func ({{$recv}} *{{ lowerCamelCase $target }}WithMetrics) {{.Name}}({{template "list" .Params}}) ({{template "list" .Returns}}) {
	done := {{$recv}}.observer.Observe(ctx, "{{.Name}}")
	defer done()
	{{template "returns" .Returns}} = {{$recv}}.wrapped{{$target}}.{{.Name}}({{template "params" .Params}})
	{{if isLastReturnError .Returns }}
		if {{ lastReturnName .Returns }} != nil {
			stats.Record(ctx, {{ lowerCamelCase $target }}CallErrorCount.M(1))
		}
	{{end}}

	return {{template "returns" .Returns}}
}
{{end}}

// Healthy calls Healthy on the wrapped wrapped{{$target}}.
func ({{$recv}} *{{ lowerCamelCase $target }}WithMetrics) Healthy() error {
	return {{$recv}}.wrapped{{$target}}.Healthy()
}

// Ready calls ready on the wrapped wrapped{{$target}}.
func ({{$recv}} *{{ lowerCamelCase $target }}WithMetrics) Ready() (bool, error) {
	return {{$recv}}.wrapped{{$target}}.Ready()
}

// Close calls Close on the wrapped wrapped{{$target}}.
func ({{$recv}} *{{ lowerCamelCase $target }}WithMetrics) Close() error {
	return {{$recv}}.wrapped{{$target}}.Close()
}

{{define "list"}}{{range $index, $element := .}}{{if $index}}, {{end}}{{if $element.Name}}{{$element.Name}}{{end}} {{$element.Type}}{{end}}{{end}}
{{define "params"}}{{range $index, $element := .}}{{if $index}}, {{end}}{{if $element.Name}}{{$element.Name}}{{$element.Suffix}}{{end}}{{end}}{{end}}
{{define "returns"}}{{range $index, $element := .}}{{if $index}}, {{end}}{{if $element.Name}}{{$element.Name}}{{end}}{{end}}{{end}}
{{define "doc"}}
{{range .Doc}}
{{.}}
{{- else}}
// {{.Name}} .
{{- end}}
{{end}}
`
